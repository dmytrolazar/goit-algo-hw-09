Для цієї задачі жадібний алгоритм значно ефективніший. Він виконується за час $O(k)$, де $k$ — це кількіть деномінацій монет.  
Коли всі деномінації монет більші за наступну меншу хоча б вдвічі, то алгоритм завжди буде повертати оптимальне значення. Як у прикладі з монетами 50, 25, 10, 5, 2, 1.  
Щоб жадібний алгоритм повернув неоптимальне значення, повинні існувати монети, які більші за половину значення наступної.  
Наприклад, якщо є монети номіналом 25, 20 і 1. Якщо треба видати 60 копійок здачі, оптимальним буде видати 3 монети по 20, а не починати з 25.

Динамічне програмування для даної задачі доцільне лише якщо обов'язково потрібне оптимальне вирішення і жадібний алгоритм може повернути неоптимальне (якщо є монети, які роблять це можливим).  
Він виконується за час $O(n \cdot k)$, де $n$ — це сума решти, яку треба видати, а $k$ — це кількіть деномінацій монет.  
Також, доцільним може бути використання динамічного програмування, якщо потрібно багато разів виконувати обрахунки, але тоді потрібно буде дописати функцію так, щоб та запам'ятовувала таблицю мемоїзації і перевикористовувала вже обраховані значення.